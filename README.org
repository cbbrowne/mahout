* Mahout Schema Manager

  What is Mahout?  Mahout is a /schema manager/ intended to ease the
  process of deploying database schema changes for PostgreSQL.

  Deploying schema changes may be very simple if you are merely
  managing a "personal" database where it is reasonable to deploy
  changes in-place.

  On the other hand, when deploying database-based applications into
  sophisticated production environments, it is crucial to be able to
  consistently duplicate the process of deploying schemas and upgrades
  in development, test, and production environments.  That is what
  Mahout tries to make a bit easier.

** Other Schema Managers

  There are a number of toolsets out there that do notionally similar
  things.

  - Sqitch :: Is a Perl-based system that supports building schema
              upgrade scripts for PostgreSQL databases.
  - Liquibase :: Supports a number of databases, implemented in Java.
  - Flyway :: Supports a number of databases, implemented in Java.

In contrast with them, Mahout
  - Only supports PostgreSQL; it makes no attempt to support other
    databases.
  - Prefers using SQL scripts as the representation of schemas
    (Liquibase seems to prefer representing database schema in an XML
    schema).
  - Has a very low "deployment footprint"; its prerequisites are minor:
    - psql :: Which you already had available if you are using PostgreSQL
    - bash :: Which you almost certainly already have around
    - pgcmp :: This is a schema comparison tool that mainly uses ~psql~ and ~bash~
    - tsort :: Part of GNU Core Utilities, used to work out dependency maps
  - Audits changes /extensively/; Mahout uses ~pgcmp~ to ensure that
    if you are attempting to deploy a change into production, and
    someone has been messing around with database schemas, you will be
    made aware of this /before/ you get part of the way through
    deploying a set of schema changes and discover them breaking.
  - Eschews the (apparently from Ruby on Rails) dogma of requiring
    forwards-and-backwards migrations.  The assumption made by Mahout
    is that your system administrators will /arrange for backup/ to
    enable rolling back should severe problems be experienced.
    Commonly, these days, filesystem snapshots tend to be a good way
    of keeping backups in case of /database disaster/.

** Derivation of the name Mahout

Mahout is the Hindi word for "elephant keeper;" as the PostgreSQL
project uses an elephant as its "visual mascot," it seems appropriate
to use "mahout" to describe a tool that helps keep database schemas
under control.

Also considered was Pahan, which is the equivalent word in Tamil.
There appears to be some record of "mahout" being used as a
perjorative involving cab drivers on Long Island near New York City,
but that's sufficiently separate as to be not relevant.

** Use Cases

There will be somewhat distinct usage patterns in 4 places where we'd
expect the tool to be used:

  - Developers :: Setting up schema to be applied
    - mahout init :: To set up a schema to be managed using mahout,
                     most likely in an SCM repository.
    - Later changes are made by adding SQL DDL scripts and control
      file entries to indicate how the DDL scripts are assembled to
      indicate how to upgrade from version to version.
    - If automated build management tools like QuickBuild, Jenkins, Maven are used to manage the deployment of builds, this may be all that developers do themselves.
    - mahout install, mahout upgrade :: When developers prepare test
         environments for unit tests, they will likely use these
         Mahout commands too.
  - Build Process :: Generation of build is done by automated processes
    - mahout capture :: This generates authoritative logged information about by-version Schema information.
    - mahout build :: This provides a nice shortcut to generate an
                      archive file comprising the bundle of schema
                      information that needs to be carried downstream.
  - QA :: Applying schema changes to sample production schemas
    - mahout check :: This checks the schema in the database out to
                      see if it matches the version it claims to be
                      on, and verifies that Mahout data has not been
                      tampered with.
    - mahout attach :: If starting with a database that has not yet
                       been /mahoutized/.
    - mahout diff :: Analyzes the current database schema for
                     differences against the version which it claims
                     to represent.
    - mahout upgrade :: Runs, in order, the needful DDL scripts to
                        upgrade the schema to the latest version.
  - Production Control and/or Data Services :: Deploying changes to production
    - mahout attach :: Only needed if attaching Mahout to a previously
                       deployed database that predates Mahout.
    - mahout check :: Verify that the production database is in good condition to be upgraded.
    - mahout diff :: Analyzes the production database schema for differences against the development schema.
    - mahout history :: List mahout activities against the production database
    - mahout upgrade :: Runs, in order, the needful DDL scripts to
                        upgrade the schema to the latest version.
    - mahout slonik :: Prepares scripts for use with Slony-I

** Mahout subcommands
 - ~mahout init directoryname~ :: Checks that it is safe to do so (e.g. - no pre-existing config files)
   - creates the directory afresh
   - Initializes a Mahout project
   - Usually to be done by developers
   - Establishes ~mahout.conf~ containing URI based on user environment
   - Creates directory ~base~ as the starting point
   - Runs ~pg_dump~ to write current schema to ~Base~
   - Runs ~pgcmp-dump~ to capture the state of ~Base~ as ~.mahout-data/Base.pgcmp~ 
 - ~mahout validate_control~ :: Checks the hygiene of the control file
   - make sure that it is well formed, with valid commands
   - make sure that scripts referenced are all present
   - make sure that requires all reference versions that are listed
   - look for version ordering loops using tsort
 - ~mahout capture~ :: This step is intended to capture ~.pgcmp~ files.
      It does an install of a specified version, and captures the
      schema into ~.pgcmp.version~.  

   - It also captures checksums (via ~md5sum~) of the referenced
     scripts so we may be certain they are up to date and that they
     have not been altered.
   - It captures ~.pgcmp~ files for /all/ versions that are
     not captured
   - It captures lists of locked objects for each ~psql~ and ~superuser~ script, thus:
     | schema | object name | Lock Acquired       |
     |--------+-------------+---------------------|
     | public | t1          | AccessExclusiveLock |
     | public | t3          | AccessShareLock     |
     | public | t3          | ShareLock           |
     This information will be useful in determining how invasive an
     upgrade will be to a live system.  Locks on tables newly
     introduced in a particular version will obviously be irrelevant,
     as a live system can't be referring to those tables until after
     the upgrade is complete.
     Look for files with the filename suffix ~.locks-acquired~
   - This is likely to be invoked by developers, perhaps with some integration with build automation
 - ~mahout install~ :: This is used to install a Mahout-managed schema
      in a fresh database.
   - This is how one would set up a fresh schema in a QA/production
     environment.
 - ~mahout attach~ :: This is used to indicate that a particular
                     version should be associated with the present
                     schema
   - This is how one would attach Mahout to an existing schema in production
   - User specifies the version of the schema that they believe is in place
   - Mahout checks that the schema matches the schema for the requested version
   - If all matches, then Mahout would attach its own metadata to enable future tracking
   - It captures expected differences for ~pgcmp~
 - ~mahout check~ :: Asks what version is in the schema indicated by
                    ~mahout.conf~, and rummages around and checks the
                    schema against that version using ~pgcmp~
   - Also verifies that upgrade scripts have not been altered by
     verifying MD5 checksums
 - ~mahout upgrade~ :: Performs all upgrades needed to upgrade from the
      present version (see ~mahout check~) to the last available, or to
      a specified version.
   - A ~dry-run~ option should list its plans in detail, providing a
     way that DBAs can know the exact intended application
     ordering of the pieces to assist them in building ~slonik~ scripts
 - ~mahout diff~ :: Finds any differences between current version and
                   what is expected (e.g. - use ~pgcmp~ to compare
                   current schema with a captured schema)
 - ~mahout history~ :: List ~mahout~ upgrade activities performed
      against the local database
 - ~mahout versions~ :: Walk configuration via ~tsort~ to get all
      versions, and check their application status in the database
 - ~mahout changes~ :: This has two perspectives:
   - List the ~mahout~ scripts that are to be applied so that DBAs can
     figure out what they need to prepare for Slony application of the
     schema
   - List the major objects that change between versions so that we
     provide useful documentation to downstream users.  They can know
     such things as
     - What tables are being added/removed
     - What tables are being altered
   - This has not yet been implemented; perhaps it is irrelevant in
     that these changes are reflected automatically by the DDL scripts
     referenced by the control script.
 - ~mahout build~ :: This takes the contents of the current Mahout
                     directory, and generates an archive containing
                     all of the data.
   - It is essentially a way of avoiding the need to run ~tar cfvz schema-version.tar.gz~
 - ~mahout slonik~ :: This generates ~slonik~ scripts for use with
                     Slony to perform the specified upgrade.
   - It only works if the version upgrade(s) /only/ consist of ~psql~
     and ~psqltest~ requests; it will /fail/ if there is a ~shell~
     step.
   - It generates a slonik script with the following:
     - a pre-amble reference to allow set IDs and connection paths to be defined by an administrator
     - an EXECUTE SCRIPT request for each ~psql~ script, to apply DDL to the cluster
     - a CREATE SET request, for the new tables and sequences that are added
     - a SET ADD TABLE for each added table
     - a SET ADD SEQUENCE for each added sequence
     - a series of SUBSCRIBE SET requests based on those already existing so that all possible nodes will receive subscriptions to the new tables
   - An alternative approach is to drop replication and recreate with the whole set of tables
     But this requires little input, so seems sensible to leave to the user...
** Mahout Directory Structure

  A schema repository will consist of a directory structure where the
  top level will have 2 "control" files, and then a series of
  directories, each indicating schema code to deployed.

  No further structure is provided, however it should be obvious that
  setting up a directory structure to group schema scripts together by
  version would be wise.

  - Configuration control file: ~mahout.conf~

    This file contains metadata about the databases to be managed.

    Alternatively, ~MAHOUTCONFIG~ may be set to indicate an
    alternative location to find the configuration expected in
    ~mahout.conf~.

  - Schema control: ~mahout.control~
    This file indicates the order in which directories/files should be visited when applying schema changes.

  - If no ~mahout.control~ file is provided, at a given directory
    level, that will be treated as an error that would cause ~mahout~
    schema application work to fail.

** Contents of mahout.conf

  - URIs to indicate how to access databases of interest
    - MAINDATABASE :: Contains the URI to be used for processing of schema files.
    - SUPERUSERACCESS :: Contains the URI to be used for anything requiring superuser access
    - COMPARISONDATABASE :: This indicates the URI of a database suitable for doing comparisons using pgcmp
    - MAHOUTOMITSCHEMAS :: This indicates a set of schemas that are to be ignored when ~pgcmp~ is being used to do comparisons.
      - It is formatted as an SQL IN clause, so should look like ('pg_catalog','information_schema','MaHoutSchema')
      - Note that ~mahout.conf~ is handled as a shell script, and, if using bash, quotes will be needed otherwise MAHOUTOMITSCHEMAS will interpret the structure as an array
    - PGCMPHOME :: Indicates the directory where the ~pgcmp~ comparison tool is installed
    - MAHOUTSCHEMA :: Indicates the schema in which to put Mahout version and logging information
  - Data files
    - In some cases, external data will be needed, /e.g./ - some
      upgrades required a data file indicating configuration of DML
      changes.

  Note that if ~MAHOUTCONFIG~ is set, then the file at the specified location will be used instead of the ~mahout.conf~ file in the Mahout archive.

#+BEGIN_EXAMPLE
COMPARISONDATABASE=postgresql://postgres@localhost:7099/comparisondb
MAHOUTOMITSCHEMAS="('pg_catalog','information_schema','MaHoutSchema')"
MAHOUTSCHEMA=MaHoutSchema
MAINDATABASE=postgresql://postgres@localhost:7099/devdb
PGCMPHOME=/home/cbbrowne/PostgreSQL/pgcmp
SUPERUSERACCESS=postgresql://postgres@localhost:7099/postgres
CONFIG_26=/tmp/redwood-upgrade-2.6.conf
CONFIG_23y=/tmp/redwood-2.3y-currencies.txt
CONFIG_2226=/tmp/registrar-guid-map-2.2.26.csv
CONFIG_22=/tmp/registrar-guid-map-2.2.csv
#+END_EXAMPLE

** Contents of mahout.control

  - It contains a series of versions, and references to the code to install the respective version
    - The first version is called "Base", and has no predecessor
    - Subsequent versions will indicate their respective predecessor
  - For each file to be loaded there must be a line in ~mahout.control~ indicating processing steps, which include:
    - psql :: Indicating that the file should be processed using ~psql~ against MAINDATABASE
    - shell :: Indicating that the file should be run as a shell
               script, with the values in ~mahout.conf~ loaded into
               the environment.  It is strongly urged that ~shell~
               only be used to handle DML changes, that is, to change
               the data /inside/ tables, as opposed to doing DML
               (table structure alterations).  ~shell~ commands are
               not amenable to capturing ~.locks-acquired~ data, as
               the script controls transaction management rather than
               Mahout doing so.

  Complex example of ~mahout.control~ (that might resemble deployment
  of schema for some particular application).
#+BEGIN_EXAMPLE
  # Note that Base is actually version 1.5; that was where we started...
  version Base
    psql Base/base-schema.sql

  common tests
    psqltest from 2.2 to 2.2.26 test/parent-test-1.sql
    psqltest from 2.2.26 test/parent-test-2.sql
    psqltest from 2.3y test/pf-currency.sql
    psqltest from 2.2 test/gf.sql
    psqltest from 2.6 test/bigint-checks.sql
    psqltest from 2.4 test/message-queuing.sql
    psqltest from 2.3z test/ropq.sql
    psqltest test/all-tables-commented.sql
    psqltest test/all-functions-commented.sql
    psqltest test/table-names-unique.sql

  version 2.0
    requires Base
    superuser 2.0/drop_roles.sql
    psql 2.0/public.sql
    psql 2.0/app_private.sql
    psql 2.0/app.sql
    psql 2.0/devtools.sql
    psqltest 2.0/new-feature-in-2.0.sql

  version 2.1
    requires 2.0
    psql 2.1/public.sql
    psql 2.1/app.sql
    psql 2.1/drop_deprecateds.sql
    psql 2.1/devtools.sql

  version 2.2
    requires 2.1
    psql 2.2/public.sql
    psql 2.2/app_private.sql
    psql 2.2/adjustment_criteria.sql
    psql 2.2/migrate_ids.sql CLIENT_ID_FILE=${CONFIG_22}

  version 2.2.26
    requires 2.2
    psql 2.2.26/public.sql
    psql 2.2.26/migrate-ids.sql CLIENT_ID_FILE=${CONFIG_2226}

  version 2.3x
    requires 2.2.26
    psql 2.3x/public.sql
    psql 2.3x/app.sql
    psql 2.3x/app_private.sql

  version 2.3y
    requires 2.3x
    psql 2.3y/public.sql
    psql 2.3y/app_private.sql
    psql 2.3y/app.sql
    psql 2.3y/devtools.sql
    shell 2.3y/migration-currency.sh PF_CURRENCY_FILE=${CONFIG_23y}
    shell 2.3y/migrate-pf-currency.sql

  version 2.3z
    requires 2.3y
    psql 2.3z/public.sql
    psql 2.3z/app_private.sql
    psql 2.3z/app.sql
    psql 2.3z/migration-script.sql

  version 2.4
    requires 2.3z
    psql 2.4/app.sql

  version 2.5
    requires 2.4
    psql 2.5/public.sql
    psql 2.5/app_private.sql
    psql 2.5/app.sql

  version 2.6
    requires 2.5
    shell 2.6/prepare-rapp-schema-upgrade.sh ${CONFIG_26}

  version 2.7
    requires 2.6
    psql 2.7/globals.sql
    psql 2.7/public.sql
    psql 2.7/app_private.sql
    psql 2.7/app.sql

  version 2.8
    requires 2.7
    psql 2.8/public.sql
#+END_EXAMPLE

** Logging to be done
 - Some output should be captured in files
 - Some data should be captured in tables in the database
   - Version number information
   - Schema Application Logs (akin to what Liquibase does), capturing, for each data file processed, the name of the file, and the timestamps of start/end of processing of each processing step.
   - Note that the version will capture which ~mahout.control~ file was the one that established each version.
   - It should capture ~md5sum~ checksums of the script files so that we can be certain that the latest scripts have been applied and carried around correctly
** Managing Mahout Schema Management Code

   Mahout does not assume anything about the use of version control
   tools; it is quite likely someone managing a schema via Mahout will
   wish to use an SCM tool such as Git or Subversion to manage the
   code that comprises the build.

*** Code that warrants version control
   - Control file: ~mahout.control~
   - Config file: ~mahout.conf~
   - Content: All files referenced in ~mahout.control~ are likely
     candidates for version control

*** Generated files likely not warranting version control

    Mahout generates content for various files that most likely should
    not be put under version control:

    - ~.mahout-data~ :: ~pgcmp~-generated encoding of schemas for each respective version
    - ~.mahout-logs~ :: Logs generated by Mahout are probably not of interest
    - ~.mahout-temp~ :: Temporary files are not of ongoing interest
    - ~.md5sum~ files :: These are checksums of schema scripts,
         intended to help detect tampering with a build.  They should
         be carried along to production, but likely do not need to be
         captured in version control.
    - ~.version.log~ files :: These are captured as log files when
         schema scripts are loaded or tests are performed against a
         particular schema version.  They are not of interest for
         version control
    - ~.version.locks-acquired~ files :: These files indicate what
         table locks are acquired when running a particular schema
         upgrade script.  They will be of analytical interest in
         determining the locking effects of a given upgrade, but, as
         they are generated data, they are probably not of much
         interest for version control.

** Turning Mahout output into a build

   The simplest answer for how to generate a build is most likely to
   be to generate a "tarball" archive consisting of all of the files
   and subdirectories under the directory containing the
   ~mahout.control~ file.

   Thus, for the schema managed by the scripts generated by the sample
   in ~test/test-build-stuff.sh~, which are written to ~test/mhtest~,
   it would be appropriate to generated a build as follows:

#+BEGIN_EXAMPLE
$ tar cfv mhtest-latest.tar mhtest
mhtest/
mhtest/Base/
mhtest/Base/base-schema.sql.md5sum
mhtest/Base/base-schema.sql
mhtest/mahout.conf
mhtest/common-tests/
mhtest/common-tests/pk-test.sql.md5sum
mhtest/common-tests/multiply-defined.sql.1.4.log
mhtest/common-tests/pk-test.sql.1.4.log
mhtest/common-tests/multiply-defined.sql
mhtest/common-tests/failing-test.sql.1.4.log
mhtest/common-tests/pk-test.sql
mhtest/common-tests/null-test.sql.1.1.log
mhtest/common-tests/multiply-defined.sql.1.3.log
mhtest/common-tests/pk-test.sql.1.2.log
mhtest/common-tests/failing-test.sql.md5sum
mhtest/common-tests/pk-test.sql.1.1.log
mhtest/common-tests/null-test.sql.md5sum
mhtest/common-tests/null-test.sql
mhtest/common-tests/failing-test.sql
mhtest/common-tests/null-test.sql.1.3.log
mhtest/common-tests/multiply-defined.sql.1.1.log
mhtest/common-tests/multiply-defined.sql.md5sum
mhtest/common-tests/pk-test.sql.1.3.log
mhtest/common-tests/null-test.sql.1.2.log
mhtest/common-tests/multiply-defined.sql.1.2.log
mhtest/1.4/
mhtest/1.4/stuff.sql
mhtest/1.4/stuff.sql.1.4.log
mhtest/1.4/stuff.sql.md5sum
mhtest/1.4/stuff.sql.1.4.locks-acquired
mhtest/mahout.control
mhtest/.mahout-logs/
mhtest/.mahout-logs/mahout.log
mhtest/.mahout-data/
mhtest/.mahout-data/1.2.pgcmp
mhtest/.mahout-data/1.3.pgcmp
mhtest/.mahout-data/1.4.pgcmp
mhtest/.mahout-data/Base.pgcmp
mhtest/.mahout-data/1.1.pgcmp
mhtest/.mahout-temp/
mhtest/.mahout-temp/capturedb.pgcmp
mhtest/.mahout-temp/setup-mahout-schema.log
mhtest/.mahout-temp/setup-mahout-schema.sql
mhtest/1.1/
mhtest/1.1/stuff.sql
mhtest/1.1/stuff.sql.md5sum
mhtest/1.1/stuff.sql.1.1.locks-acquired
mhtest/1.1/stuff.sql.1.1.log
mhtest/1.3/
mhtest/1.3/stuff.sql
mhtest/1.3/stuff.sql.md5sum
mhtest/1.3/stuff.sql.1.3.locks-acquired
mhtest/1.3/stuff.sql.1.3.log
mhtest/1.2/
mhtest/1.2/stuff.sql.1.2.log
mhtest/1.2/stuff.sql
mhtest/1.2/stuff.sql.md5sum
mhtest/1.2/stuff.sql.1.2.locks-acquired
#+END_EXAMPLE

The resulting build file, ~mhtest-latest.tar~, may be carried to other
environments, and used, once extracted, to install the schema.

Various sorts of files were discussed earlier in relation to SCM
version control; covering them in terms of their needfulness for
deploying schemas:

 - Control file :: ~mahout.control~
 - Config file :: ~mahout.conf~
   - Note that when deploying the schema into a production
     environment, ~mahout.conf~ will need to be altered to indicate
     configuration in the production environment, as the locations of
     directories and databases are quite likely to differ from
     development or QA environments.
 - Content :: Files referenced in ~mahout.control~ need to be
              included.  Test scripts /could/ be considered optional,
              as tests might not be applied in the production
              environment, however, little is to be gained from their
              removal.
 - Encoded schemas - ~.mahout-data~ :: Must be included to allow
      testing that the target database starts with a compatible
      schema.
 - Log files - ~.mahout-logs~ :: Logs generated by Mahout are probably not of interest
 - Temp files - ~.mahout-temp~ :: Temporary files are not of ongoing interest
 - Checkums - ~.md5sum~ files :: The checksum files are needed, as they protect against tampering with a build.
 - Version log ~.version.log~ files :: Probably not of much interest
 - Lock ~.version.locks-acquired~ files :: These files indicate which
      table locks are acquired when running a particular schema
      upgrade script.  They will be of analytical/documentary interest
      in determining the locking effects of a given upgrade.

** Prerequisites

   What do you need to have available in order to run mahout?

   - bash :: Mahout is written in Bash
   - PostgreSQL :: A reasonably modern version; probably 9.3 is modern enough.
     - psql :: SQL is run using ~psql~
     - pg_dump :: Schema dump for the "Base" version is captured using ~pg_dump~
   - logger :: Logger is used to capture logs centrally
   - date :: Captures dates
   - pgcmp :: Mahout uses ~pgcmp~ to compare schema versions in order
              to ensure that schemas are not corrupted in
              transmission.
   - md5sum :: Used to detect if schema scripts have been modified/corrupted in transmission
     - Note that we are not doing anything "cryptographically strong"
       with this; it would be easy enough for someone trying to defeat
       the checksums to simply replace them, and that would be
       impractical to prevent.
   - String tools
     - cut
     - sed
     - egrep
     - cat
   - tsort :: Used to do a topological sort to determine the ordering
              that falls from version dependencies.
   
** Open questions
 - Can we/should we try to capture ~slonik~ ~SET ADD TABLE~ requests
   by peeking at the application of DDL?

** Things Mahout does not itself do that we do today in Registry Universal Schema

These things need to be covered somewhere.

*** Permissions Provisioning

There is a fairly sophisticated permissions model constructed out of:
 - Matrix of detailed permissions for Registry-services-managed roles
 - Schema-based (e.g. - granting same permissions for a whole
   "directory" of objects) for other roles

Perhaps this no longer needs to be covered by specific "permissions
provisioning" tools; having regression tests that verify that
permissions have been provisioned will be sufficient.

*** Testing schema for various conditions

There are a set of tests in the ~universal-schema~ build today that
verify several things.  The Mahout ~psqltest~ facility should nicely
cover these sorts of requirements.

  - Common rules
    - Verify that all functions, tables, columns are commented
    - Verify that all tables have primary keys
    - Verify that table names are unique
  - Unit tests
    - Grandfathering
    - Message queueing
    - Policy cuts
    - Premium pricing
    - Registry operator poll queue
    - VAT

*** Automatically generating documentation

We automatically generate documentation using
  - Schema Spy
  - PostgreSQL autodoc

Mahout would not automatically provide this.  It could be an
interesting extension for Mahout to generate per-version copies of
documentation, but it is likely appropriate for this to be separated
out and generated separately.

** Unorganized Requirement Ideas
The upgrade system needs to identify and control all schema changes to
be made.

- User that runs updates
  - Usually should be schema owner
  - Some changes must be handled via superuser
- Multiple SQL scripts
  - Need a mechanism to order them
- Nice to have: ensure DDL and DML do not get done in the same script
  - Can this be verified automatically?
- Configuration file that indicates
  - Place to log things
  - Postgres binaries
  - PostgreSQL URI
- Version number capture
  - We use stuff in ~upgrade_version_to_latest.sh~ to indicate
    the version in the ~_oxrsversion~ schema
  - Current stuff is:
    - Branch :: which may become the version label
    - Generated on host :: Reasonable for Mahout to do differently
    - Generated at time :: Reasonable for Mahout to do differently
    - SCM checkout information :: Reasonable for Mahout to do differently
- Log activity
  - For each sub-component, identify what was run, when it ran, how long it took
  - Some may go into database
  - Successes are no problem; failed schema would be troublesome to get into DB as requests would fail
  - Probably need to determine how to serialize some logs into filesystem
- Supplemental configuration
- Standard tests
  - Check that functions all have comments
  - Check that tables and views all have role-based permissions attached to them
  - Check that tables all have primary keys-
  - Check that tables have unique names
  - Check that tables and their columns have comments
  - Hooks to allow running custom tests
  - Which tests to run against which versions?
- We'll have several kinds of things to execute...
  - SQL scripts that need to be run
  - Shell scripts that need to be run
  - Might there be some Python?
- Various pre- and post-conditions
  - Run ~pgcmp~ to check that schema matches expectations, e.g. - captured ~pgcmp-dump~ matches the schema
  - Need a mechanism that runs ~pgcmp-dump~ to capture schema at various points
  - Run tests, and capture either perfect conformance or counts/details of non-conformance?
- Seeding
  - Security needs
    - Roles
      - What to do about the possibility of needful roles evolving over time?
    - Basic users
      - Basic information needed will be
        - Owner
        - Superuser (hopefully little needed)
- Version and tagging model

